COMPILER MAGIA

    /*
    public SymbolTable   tab;
    public CodeGenerator gen;
    */
  
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  CharInLine = ANY - '\r' - '\n'.
  AnyButDoubleQuote = CharInLine - '\"'.

TOKENS
  IDENT  = letter {letter | digit | '_'}.
  NUMBER = digit {digit} | digit {digit} '.' digit {digit}.
  TEXT = '"' {AnyButDoubleQuote | "\\\""} '"'.
  NONE = "none".
  TRUE = "true".
  FALSE = "false".
  RPAREN = ')'.
  
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
MAGIA =                             (. HeadNode headNode; mainNode = new MAGIA(); .)
    {SYNC Head<out headNode>        (. mainNode.Add(headNode);                    .)
    } 
    Stmts 
    {FuncDecl}.
    
/*------------------------------------------------------------------------*/
Head<out HeadNode headNode>              (. headNode = null; .) 
    = '[' 
    ( "vertex"                           (. headNode = new HeadNode(HeadNode.VERTEX); .)
    | "edge"                             (. headNode = new HeadNode(HeadNode.EDGE);   .)
    ) 
    WEAK '(' AttrDecls<ref headNode>
    WEAK ')' ']'.

/*------------------------------------------------------------------------*/
AttrDecls<ref HeadNode headNode>
    = AttrDecl<out varDecl>              (. headNode.AddAttr(varDecl); .)
    {
        WEAK ',' AttrDecl<out varDecl>   (. headNode.AddAttr(varDecl); .)
    }.

/*------------------------------------------------------------------------*/
AttrDecl<out VarDeclNode varDecl> = (. varDecl = null; .)
    Type<out int typ>
    IDENT
    [
        Assign<>
    ]
    .


/*------------------------------------------------------------------------*/
/*The IF command makes the parser read a token ahead to see whether the function declaration has any parameters
or if it is simply an empty pair of parenthisis. If a right parenthisis is read, there is no parameters,
so FuncParams can safely be skipped, but if any non-right parenthisis is read, then FuncParam will be called
and any eventual errors will be handled there*/

FuncDecl
    = SYNC "func" IDENT '(' [IF(la.kind != _RPAREN) FuncParams] ')' SYNC '{' Stmts SYNC '}'.

/*------------------------------------------------------------------------*/
FuncParams<ref FuncDeclNode funcNode> = (. int typ = 0;  .)
    Type<out typ> 
    IDENT                               (. funcNode.AddParam(new VarDeclNode(typ, t.val, null)); .)
    {
        SYNC ',' Type<out typ>
        IDENT                           (. funcNode.AddParam(new VarDeclNode(typ, t.val, null)); .)
    }.


/*------------------------------------------------------------------------*/
Stmts
    = SYNC {Stmt | StrucStmt}.

/*------------------------------------------------------------------------*/
StrucStmt<out StmtNode s>			(. s = null; .)
    = StmtWhile<out s>				
	| StmtFor<out s>				
	| StmtForeach<out s>			
	| StmtIf<out s>.

/*------------------------------------------------------------------------*/
StmtWhile<out WhileNode w>				(. w = null; Block b = new Block(); .)
	= "while" '(' Expr<out ExprNode e>	
		')' '{' Stmts<ref b>			(. w = new WhileNode(e, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtFor<out ForNode f>						(. f = null; StmtNode init = null; ExprNode e = null; StmtNode iter = null; Block b = new Block(); .)
	= "for" '(' Stmt<out StmtNode s1>		(. init = s1; .)
		',' Expr<out ExprNode e1>			(. e = e1;  .)
		',' Stmt<out StmtNode s2>			(. iter = s2; .)
		')' '{' Stmts<ref b>				(. f = new ForNode(init, e, iter, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtForeach<out ForeachNode f>				(. f = null; Block b = new Block();, VarDeclNode v = null; .)
	= "foreach" '(' Type<out int typ>
		IDENT								(. v = new VarDeclNode(typ, t.val, null); .)
		"in" Expr<out ExprNode e1>			(.  .)
		')' '{' Stmts<ref b>				(. f = new ForeachNode(v, e1, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtIf<out IfNode i>									(. i = null; ExprNode e = null; Block b = new Block(); IfNode j = null; Ifnode k = null; .)
	= "if" '(' Expr<out ExprNode ie1>					(. e = ie1; .)
		')' '{' Stmts<ref b>							(. i = new IfNode(e, b); j = i; .)
		'}' {"elseif" '(' Expr<out ExprNode ie2>		(. e = ie2; b = new Block(); .)
		')' '{' Stmts<ref b>							(. k = new IfNode(e, b); j.SetElse(k); j = k;  .)
		'}'} ["else"									(. b = new Block(); .)
		'{' Stmts<ref b>							    (. ; k = new IfNode(new BoolConst(true), b); j.SetElse(k).)
		'}'].

/*------------------------------------------------------------------------*/
Stmt
    = (FullDecl | CallOrID {Member} IdentCont | "return" Expr).

/*------------------------------------------------------------------------*/
IdentCont
    = Assign | EdgeOpr EdgeOneOrMore.

/*------------------------------------------------------------------------*/
Member
    = WEAK '.' CallOrID.

/*------------------------------------------------------------------------*/
FullDecl
    = Type (IDENT [Assign] | '{' VtxDecls '}' | VtxDecl).

/*------------------------------------------------------------------------*/
Assign<out AssignNode assign>           (.  .)
    = '=' 
    (Expr<out Expr expr>                (.  .)
    | '{' Args<out CollecConst collec> 
    '}'
    ).

/*------------------------------------------------------------------------*/
VtxDecls
    = VtxDecl {WEAK ',' VtxDecl}.

/*------------------------------------------------------------------------*/
VtxDecl
    = '(' IDENT VEParams ')'.

/*------------------------------------------------------------------------*/
EdgeOpr
    = ("<-" | "--" | "->").

/*------------------------------------------------------------------------*/
EdgeOneOrMore
    = (Identifier | EdgeDecl | '{' EdgeDecls '}').

/*------------------------------------------------------------------------*/
EdgeDecls 
    = EdgeDecl {WEAK ',' EdgeDecl}.

/*------------------------------------------------------------------------*/
EdgeDecl 
    = '(' IDENT VEParams ')'.


/*------------------------------------------------------------------------*/
VEParams
    = {WEAK ',' Identifier Assign}.


/*------------------------------------------------------------------------*/
Expr<out Expr e> (. e = null; .)
    = ExprOR<out e>.
    
/*------------------------------------------------------------------------*/
ExprOR<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprAnd<out ExprNode e1>			(. e = e1; .)
	{"||"								(. op  = Operators.OR; .)
	ExprAnd<out ExprNode e2> 			(. e = new BinExprNode(e, op, e2); .)								
	}.

/*------------------------------------------------------------------------*/
ExprAnd<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprEQ<out ExprNode e1>			(. e = e1; .)
	{"&&"								(. op = Operators.EQ; .)
	ExprEQ<out ExprNode e2> 			(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprEQ<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprRel<out ExprNode e1>			(. e = e1; .)
	[("=="								(. op = Operators.EQ; .)
	| "!="								(. op = Operators.NEQ; .)
	) ExprRel<out ExprNode e2>	    (. e = new BinExprNode(e, op, e2); .)
	].

/*------------------------------------------------------------------------*/
ExprRel<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprPlus<out ExprNode e1>			(. e = e1; .)
	[('<'								(. op = Operators.LESS; .)
	| '>'								(. op = Operators.GREATER; .)
	| "<="								(. op = Operators.LESSEQ; .)
	| ">="								(. op = Operators.GREATEQ; .)
	) ExprPlus<out ExprNode e2>		(. e = new BinExprNode(e, op, e2); .)
	].

/*------------------------------------------------------------------------*/
ExprPlus<out ExprNode e>				(. e = null; bool b = false; int op = 0; .)
    = ['-'								(. b = true; .)
	] ExprMult<out ExprNode e1>			(. if(b) e = new UnaExprNode(Operators.UMIN, e1); else e = e1; .)
	{('+'								(. op = Operators.PLUS; .)
	| '-'								(. op = Operators.BIMIN; .)
	) ExprMult<out ExprNode>			(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprMult<out ExprNode e>				(. e = null; int op = 0;.)
    = ExprNot<out ExprNode e1>			(. e = e1; .)
	{('*'								(. op = Operators.MULT; .)
	| '/'								(. op = Operators.DIV; .)
	| '%'								(. op = Operators.MOD; .)
	) ExprNot<out ExprNode e2>		(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprNot<out ExprNode e>			(. e = null; bool b = false;.)
    = ['!'                      (. b = true; .)
	] Factor<out e>            (. if(b) e = new UnaExprNode(Operators.NOT, e); .)
	.

/*------------------------------------------------------------------------*/
Factor<out ExprNode e>			(. e = null; .)
    = Const<out e>				              
	| ('(' Expr<out e> ')' | CallOrID<out e>) {Member}.		


/*------------------------------------------------------------------------*/
CallOrID<out IdentNode i>
    = Identifier ['(' Args<out CollecConst collec> ')'].

/*------------------------------------------------------------------------*/
Args<out CollecConst collec> =      (. collec = new CollecConst(); Expr expr; .)
    [
        Expr<out expr>              (. collec.Add(expr); .)
        {
            WEAK ',' Expr<out expr> (. collec.Add(expr); .)
        }
    ].


/*------------------------------------------------------------------------*/
Identifier<out IdentNode identNode> = (. identNode = null; .)
    (
        IDENT                         (. identNode = new IdentNode(t.val); .)
    ).

/*------------------------------------------------------------------------*/
Const<out ExprNode e> =     (. e = null; .)
    ( NUMBER				(. e = new NumConst(Convert.ToInt32(t.val));    .)
    | TEXT					(. e = new TextConst(t.val);                    .)
    | TRUE					(. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | FALSE					(. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | NONE					(. e = new NoneConst();                         .)
    ).

/*------------------------------------------------------------------------*/
Type<out int type> =
    ( SingleType<out type>				
    | CollecType<out type>
    ).

/*------------------------------------------------------------------------*/
CollecType<out int type> =                                     (. type = 0; subType = 0; .)
    ( "list" WEAK '<' SingleType<out subType> WEAK '>'	       (. type = Types.list + subType; .)
    | "set" WEAK '<' SingleType<out subType> WEAK '>'           (. type = Types.set + subType; .)
    | "queue" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.queue + subType; .)
    | "stack" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.stack + subType; .)
    ).
/*------------------------------------------------------------------------*/
SingleType<out int type> = (. type = 0; .)
    ( "number"             (. type = Types.number;.)
    | "bool"			   (. type = Types.boolean;.)
    | "text"			   (. type = Types.text; .)
    | "vertex"             (. type = Types.vertex; .)
    | "edge"               (. type = Types.edge; .)
    ).

/*------------------------------------------------------------------------*/

END MAGIA.
