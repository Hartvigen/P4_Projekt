COMPILER MAGIA

    /*
    public SymbolTable   tab;
    public CodeGenerator gen;
    */
  
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  CharInLine = ANY - '\r' - '\n'.
  AnyButDoubleQuote = CharInLine - '\"'.

TOKENS
  IDENT  = letter {letter | digit | '_'}.
  NUMBER = digit {digit} | digit {digit} '.' digit {digit}.
  TEXT = '"' {AnyButDoubleQuote | "\\\""} '"'.
  NONE = "none".
  TRUE = "true".
  FALSE = "false".
  RPAREN = ')'.
  
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
MAGIA =                                     (. mainNode = null; Block mainBlock = new Block(); .)
    {SYNC Head<out HeadNode headNode>       (. mainBlock.Add(headNode); .)
    } 
    Stmts<ref mainBlock>
    { FuncDecl<out FuncDeclNode funcNode>   (. mainBlock.Add(funcNode); .)
    }                                       (. mainNode = new MAGIA(mainBlock); .)
    .
    
/*------------------------------------------------------------------------*/
Head<out HeadNode headNode>              (. headNode = null; .) 
    = '[' 
    ( "vertex"                           (. headNode = new HeadNode(HeadNode.VERTEX); .)
    | "edge"                             (. headNode = new HeadNode(HeadNode.EDGE);   .)
    ) 
    WEAK '(' AttrDecls<ref headNode>
    WEAK ')' ']'.

/*------------------------------------------------------------------------*/
AttrDecls<ref HeadNode headNode> =      (. VarDeclNode attrDecl; .)
    AttrDecl<out attrDecl>               (. headNode?.AddAttr(attrDecl); .)
    {
        WEAK ',' AttrDecl<out attrDecl>  (. headNode?.AddAttr(attrDecl); .)
    }.

/*------------------------------------------------------------------------*/
AttrDecl<out VarDeclNode attrDecl> = (. attrDecl = null; string name = ""; ExprNode val = null; .)
    Type<out int typ>
    IDENT                            (. name = t.val; .)
    [
        Assign<out val> 
    ]                                (. attrDecl = new VarDeclNode(typ, name, val); .)
    .


/*The IF command makes the parser read a token ahead to see whether the function declaration has any parameters
or if it is simply an empty pair of parenthisis. If a right parenthisis is read, there is no parameters,
so FuncParams can safely be skipped, but if any non-right parenthisis is read, then FuncParam will be called
and any eventual errors will be handled there*/
/*------------------------------------------------------------------------*/
FuncDecl<out FuncDeclNode funcNode> =                           (. funcNode = null; string funcName = ""; Block paramBlock = new Block(); Block stmtBlock = new Block(); .)
    SYNC "func" IDENT                                           (. funcName = t.val; .)
    '(' 
        [
            IF(la.kind != _RPAREN) FuncParams<ref paramBlock>
        ] 
    ')' 
    SYNC '{' 
        Stmts<ref stmtBlock>                                    
    SYNC '}'                                                    (. funcNode = new FuncDeclNode(funcName, paramBlock, stmtBlock); .)
    .

/*------------------------------------------------------------------------*/
FuncParams<ref Block paramBlock> =          (. int typ = 0; .)
    Type<out typ> 
    IDENT                                   (. paramBlock.Add(new VarDeclNode(typ, t.val, null)); .)
    {
        SYNC ',' Type<out typ>
        IDENT                               (. paramBlock.Add(new VarDeclNode(typ, t.val, null)); .)
    }.


/*------------------------------------------------------------------------*/
Stmts<ref Block block> =
    SYNC {
          FullDecl<ref block>
        | Stmt<out StmtNode stmtNode>       (. block.Add(stmtNode); .)
        | StrucStmt<out StmtNode stmtNode>  (. block.Add(stmtNode); .)
    }.

/*------------------------------------------------------------------------*/
StrucStmt<out StmtNode s>			        (. s = null; .)
    = StmtWhile<out s>				
	| StmtFor<out s>				
	| StmtForeach<out s>			
	| StmtIf<out s>.

/*------------------------------------------------------------------------*/
StmtWhile<out StmtNode w>				    (. w = null; Block b = new Block(); .)
	= "while" '(' Expr<out ExprNode e>	
		')' '{' Stmts<ref b>			    (. w = new WhileNode(e, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtFor<out StmtNode f>						(. f = null; StmtNode init = null; ExprNode e = null; StmtNode iter = null; Block b = new Block(); .)
	= "for" '(' Stmt<out StmtNode s1>		(. init = s1; .)
		',' Expr<out ExprNode e1>			(. e = e1;  .)
		',' Stmt<out StmtNode s2>			(. iter = s2; .)
		')' '{' Stmts<ref b>				(. f = new ForNode(init, e, iter, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtForeach<out StmtNode f>				    (. f = null; Block b = new Block(); VarDeclNode v = null; .)
	= "foreach" '(' Type<out int typ>
		IDENT								(. v = new VarDeclNode(typ, t.val, null); .)
		"in" Expr<out ExprNode e1>			(.  .)
		')' '{' Stmts<ref b>				(. f = new ForeachNode(v, e1, b); .)
		'}'.

/*------------------------------------------------------------------------*/
StmtIf<out StmtNode i>									(. i = null; ExprNode e = null; Block b = new Block(); IfNode j = null; IfNode k = null; .)
	= "if" '(' Expr<out ExprNode ie1>					(. e = ie1; .)
		')' '{' Stmts<ref b>							(. i = new IfNode(e, b); j = (IfNode)i; .)
		'}' {"elseif" '(' Expr<out ExprNode ie2>		(. e = ie2; b = new Block(); .)
		')' '{' Stmts<ref b>							(. k = new IfNode(e, b); j.SetElse(k); j = k;  .)
		'}'} ["else"									(. b = new Block(); .)
		'{' Stmts<ref b>							    (. k = new IfNode(new BoolConst(true), b); j.SetElse(k); .)
		'}'].

/*------------------------------------------------------------------------*/
Stmt<out StmtNode stmtNode> =               (. stmtNode = null; .)
    ( 
        CallOrID<out IdentNode i>
        { 
            Member
        } 
        IdentCont
	| 
        "return" Expr<out ExprNode expr>
	).

/*------------------------------------------------------------------------*/
IdentCont
    = Assign<out ExprNode assign> | EdgeOpr<out int i> EdgeOneOrMore.


/*------------------------------------------------------------------------*/
Member
    = WEAK '.' CallOrID<out IdentNode i>
	.

/*------------------------------------------------------------------------*/
FullDecl<ref Block block> =
    Type<out int typ> 
    (
        IDENT                               (. string name = t.val; ExprNode expr = null; .)
        [
            Assign<out expr>
        ]                                   (. block.Add(new VarDeclNode(typ, name, expr)); .)
    | 
        '{' 
            VtxDecls<ref block>
        '}' 
    | 
        VtxDecl<out VEDeclNode veDecl>      (. block.Add(veDecl); .)
    ).

/*------------------------------------------------------------------------*/
Assign<out ExprNode expr>                   (. expr = null; .)
    = '=' 
    (Expr<out expr>
    | '{' Args<out CollecConst collec>      (. expr = collec; .)
    '}'
    ).

/*------------------------------------------------------------------------*/
VtxDecls<ref Block b>							
    = VtxDecl<out VEDeclNode v1>		    (. b.Add(v1); .)
	{WEAK ',' VtxDecl<out VEDeclNode v2>	(. b.Add(v2); .)
	}.

/*------------------------------------------------------------------------*/
VtxDecl<out VEDeclNode v>					(. v = null; .)
    = '(' IDENT			                    (. v = new VEDeclNode(Types.vertex, t.val); .)
	VEParams<out AssignNode a>			    (. v.AddAttr(a); .)
	')'.


/*------------------------------------------------------------------------*/
EdgeOpr<out int op>			(. op = 0;					 .)
    = ("<-"					(. op = Operators.LEFTARR;	 .)
	| "--"					(. op = Operators.NONARR;	 .)
	| "->"					(. op = Operators.RIGHTARR;	 .)
	).

/*------------------------------------------------------------------------*/
EdgeOneOrMore
    = (Identifier<out IdentNode identNode>
	| EdgeDecl
	| '{' EdgeDecls
	'}').

/*------------------------------------------------------------------------*/
EdgeDecls 
    = EdgeDecl
	{WEAK ',' EdgeDecl
	}.

/*------------------------------------------------------------------------*/
EdgeDecl 
    = '(' IDENT
	VEParams<out AssignNode assign>
	')'.


/*------------------------------------------------------------------------*/
VEParams<out AssignNode assign>     (. assign = null; .)
    = {WEAK ',' Identifier<out IdentNode identNode> Assign<out ExprNode assign>}.


/*------------------------------------------------------------------------*/
Expr<out ExprNode e> (. e = null; .)
    = ExprOR<out e>.
    
/*------------------------------------------------------------------------*/
ExprOR<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprAnd<out ExprNode e1>			(. e = e1; .)
	{"||"								(. op  = Operators.OR; .)
	ExprAnd<out ExprNode e2> 			(. e = new BinExprNode(e, op, e2); .)								
	}.

/*------------------------------------------------------------------------*/
ExprAnd<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprEQ<out ExprNode e1>			(. e = e1; .)
	{"&&"								(. op = Operators.EQ; .)
	ExprEQ<out ExprNode e2> 			(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprEQ<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprRel<out ExprNode e1>			(. e = e1; .)
	[("=="								(. op = Operators.EQ; .)
	| "!="								(. op = Operators.NEQ; .)
	) ExprRel<out ExprNode e2>	    (. e = new BinExprNode(e, op, e2); .)
	].

/*------------------------------------------------------------------------*/
ExprRel<out ExprNode e>					(. e = null; int op = 0; .)
    = ExprPlus<out ExprNode e1>			(. e = e1; .)
	[('<'								(. op = Operators.LESS; .)
	| '>'								(. op = Operators.GREATER; .)
	| "<="								(. op = Operators.LESSEQ; .)
	| ">="								(. op = Operators.GREATEQ; .)
	) ExprPlus<out ExprNode e2>		    (. e = new BinExprNode(e, op, e2); .)
	].

/*------------------------------------------------------------------------*/
ExprPlus<out ExprNode e>				(. e = null; bool b = false; int op = 0; .)
    = ['-'								(. b = true; .)
	] ExprMult<out ExprNode e1>			(. if(b) e = new UnaExprNode(Operators.UMIN, e1); else e = e1; .)
	{('+'								(. op = Operators.PLUS; .)
	| '-'								(. op = Operators.BIMIN; .)
	) ExprMult<out ExprNode e2>			(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprMult<out ExprNode e>				(. e = null; int op = 0;.)
    = ExprNot<out ExprNode e1>			(. e = e1; .)
	{('*'								(. op = Operators.MULT; .)
	| '/'								(. op = Operators.DIV; .)
	| '%'								(. op = Operators.MOD; .)
	) ExprNot<out ExprNode e2>		(. e = new BinExprNode(e, op, e2); .)
	}.

/*------------------------------------------------------------------------*/
ExprNot<out ExprNode e>			(. e = null; bool b = false;.)
    = ['!'                      (. b = true; .)
	] Factor<out e>            (. if(b) e = new UnaExprNode(Operators.NOT, e); .)
	.

/*------------------------------------------------------------------------*/
Factor<out ExprNode e>			(. e = null; .)
    = Const<out e>				              
	| ('(' Expr<out e> ')' | CallOrID<out IdentNode i>) {Member}.		


/*------------------------------------------------------------------------*/
CallOrID<out IdentNode i>
    = Identifier<out i> ['(' Args<out CollecConst collec> ')'].

/*------------------------------------------------------------------------*/
Args<out CollecConst collec> =      (. collec = new CollecConst(); ExprNode expr; .)
    [
        Expr<out expr>              (. collec.Add(expr); .)
        {
            WEAK ',' Expr<out expr> (. collec.Add(expr); .)
        }
    ].


/*------------------------------------------------------------------------*/
Identifier<out IdentNode identNode> = (. identNode = null; .)
    (
        IDENT                         (. identNode = new IdentNode(); .)
    ).

/*------------------------------------------------------------------------*/
Const<out ExprNode e> =     (. e = null; .)
    ( NUMBER				(. e = new NumConst(Convert.ToInt32(t.val));    .)
    | TEXT					(. e = new TextConst(t.val);                    .)
    | TRUE					(. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | FALSE					(. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | NONE					(. e = new NoneConst();                         .)
    ).

/*------------------------------------------------------------------------*/
Type<out int type> =        (. type = 0; .)
    ( SingleType<out type>				
    | CollecType<out type>
    ).

/*------------------------------------------------------------------------*/
CollecType<out int type> =                                     (. type = 0; int subType = 0; .)
    ( "list" WEAK '<' SingleType<out subType> WEAK '>'	       (. type = Types.list + subType; .)
    | "set" WEAK '<' SingleType<out subType> WEAK '>'           (. type = Types.set + subType; .)
    | "queue" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.queue + subType; .)
    | "stack" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.stack + subType; .)
    ).
/*------------------------------------------------------------------------*/
SingleType<out int type> = (. type = 0; .)
    ( "number"             (. type = Types.number;.)
    | "bool"			   (. type = Types.boolean;.)
    | "text"			   (. type = Types.text; .)
    | "vertex"             (. type = Types.vertex; .)
    | "edge"               (. type = Types.edge; .)
    ).

/*------------------------------------------------------------------------*/

END MAGIA.
