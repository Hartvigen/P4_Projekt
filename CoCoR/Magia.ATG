COMPILER MAGIA

    /*
    public SymbolTable   tab;
    public CodeGenerator gen;
    */
  
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  CharInLine = ANY - '\r' - '\n'.
  AnyButDoubleQuote = CharInLine - '\"'.

TOKENS
  IDENT  = letter {letter | digit | '_'}.
  NUMBER = digit {digit} | digit {digit} '.' digit {digit}.
  TEXT = '"' {AnyButDoubleQuote | "\\\""} '"'.
  NONE = "none".
  TRUE = "true".
  FALSE = "false".
  RPAREN = ')'.
  
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab



PRODUCTIONS
/*------------------------------------------------------------------------*/
MAGIA =                                     (. mainNode = null; Block mainBlock = new Block(); .)
    {SYNC Head<out HeadNode headNode>       (. mainBlock.Add(headNode); .)
    } 
    Stmts<ref mainBlock>
    { FuncDecl<out FuncDeclNode funcNode>   (. mainBlock.Add(funcNode); .)
    }                                       (. mainNode = new MAGIA(mainBlock); .)
    .
    
/*------------------------------------------------------------------------*/
Head<out HeadNode headNode>              (. headNode = null; .) 
    = '[' 
    ( "vertex"                           (. headNode = new HeadNode(HeadNode.VERTEX); .)
    | "edge"                             (. headNode = new HeadNode(HeadNode.EDGE);   .)
    ) 
    WEAK '(' AttrDecls<ref headNode>
    WEAK ')' ']'.

/*------------------------------------------------------------------------*/
AttrDecls<ref HeadNode headNode> =          (. VarDeclNode attrDecl; .)
    AttrDecl<out attrDecl>                  (. headNode?.AddAttr(attrDecl); .)
    {
        WEAK ',' AttrDecl<out attrDecl>     (. headNode?.AddAttr(attrDecl); .)
    }.

/*------------------------------------------------------------------------*/
AttrDecl<out VarDeclNode attrDecl> = (. attrDecl = null; string name = ""; ExprNode val = null; .)
    Type<out int typ>
    IDENT                            (. name = t.val; .)
    [
        Assign<out val> 
    ]                                (. attrDecl = new VarDeclNode(typ, name, val); .)
    .


/*The IF command makes the parser read a token ahead to see whether the function declaration has any parameters
or if it is simply an empty pair of parenthisis. If a right parenthisis is read, there is no parameters,
so FuncParams can safely be skipped, but if any non-right parenthisis is read, then FuncParam will be called
and any eventual errors will be handled there*/
/*------------------------------------------------------------------------*/
FuncDecl<out FuncDeclNode funcNode> =                           (. funcNode = null; string funcName = ""; Block paramBlock = new Block(); Block stmtBlock = new Block(); .)
    SYNC "func" IDENT                                           (. funcName = t.val; .)
    '(' 
        [
            IF(la.kind != _RPAREN) FuncParams<ref paramBlock>
        ] 
    ')' 
    SYNC '{' 
        Stmts<ref stmtBlock>                                    
    SYNC '}'                                                    (. funcNode = new FuncDeclNode(funcName, paramBlock, stmtBlock); .)
    .

/*------------------------------------------------------------------------*/
FuncParams<ref Block paramBlock> =          (. int typ = 0; .)
    Type<out typ> 
    IDENT                                   (. paramBlock.Add(new VarDeclNode(typ, t.val, null)); .)
    {
        SYNC ',' Type<out typ>
        IDENT                               (. paramBlock.Add(new VarDeclNode(typ, t.val, null)); .)
    }.


/*------------------------------------------------------------------------*/
Stmts<ref Block block> =
    SYNC {
          FullDecl<ref block>
        | Stmt<out StmtNode stmtNode>       (. block.Add(stmtNode); .)
        | StrucStmt<out StmtNode stmtNode>  (. block.Add(stmtNode); .)
    }.

/*------------------------------------------------------------------------*/
StrucStmt<out StmtNode s>                   (. s = null; .)
    = StmtWhile<out s>
    | StmtFor<out s>
    | StmtForeach<out s>
    | StmtIf<out s>.

/*------------------------------------------------------------------------*/
StmtWhile<out StmtNode w>                   (. w = null; Block b = new Block(); .)
    = "while" '(' Expr<out ExprNode e>    
        ')' '{' Stmts<ref b>                (. w = new WhileNode(e, b); .)
        '}'.

/*------------------------------------------------------------------------*/
StmtFor<out StmtNode f>                     (. f = null; StmtNode init = null; ExprNode e = null; StmtNode iter = null; Block b = new Block(); .)
    = "for" '(' Stmt<out StmtNode s1>       (. init = s1; .)
        ',' Expr<out ExprNode e1>           (. e = e1;  .)
        ',' Stmt<out StmtNode s2>           (. iter = s2; .)
        ')' '{' Stmts<ref b>                (. f = new ForNode(init, e, iter, b); .)
        '}'.

/*------------------------------------------------------------------------*/
StmtForeach<out StmtNode f>                 (. f = null; Block b = new Block(); VarDeclNode v = null; .)
    = "foreach" '(' Type<out int typ>
        IDENT                               (. v = new VarDeclNode(typ, t.val, null); .)
        "in" Expr<out ExprNode e1>
        ')' '{' Stmts<ref b>                (. f = new ForeachNode(v, e1, b); .)
        '}'.

/*------------------------------------------------------------------------*/
StmtIf<out StmtNode i>                                  (. i = null; ExprNode e = null; Block b = new Block(); IfNode j = null; IfNode k = null; .)
    = "if" '(' Expr<out ExprNode ie1>                   (. e = ie1; .)
        ')' '{' Stmts<ref b>                            (. i = new IfNode(e, b); j = (IfNode)i; .)
        '}' {"elseif" '(' Expr<out ExprNode ie2>        (. e = ie2; b = new Block(); .)
        ')' '{' Stmts<ref b>                            (. k = new IfNode(e, b); j.SetElse(k); j = k; .)
        '}'} ["else"                                    (. b = new Block(); .)
        '{' Stmts<ref b>                                (. k = new IfNode(new BoolConst(true), b); j.SetElse(k); .)
        '}'].

/*------------------------------------------------------------------------*/
Stmt<out StmtNode stmtNode> =                       (. stmtNode = null; .)
    ( 
        CallOrID<out IdentNode i>                   (. stmtNode = new LoneCallNode(i); .)
        { 
            Member<i, out MemberNode member>        (. i = member; stmtNode = new LoneCallNode(i); .)
        } 
        [IdentCont<i, out StmtNode stmt>            (. stmtNode = stmt; .)
        ]            
    | 
        "return" Expr<out ExprNode expr>            (. stmtNode = new ReturnNode(expr); .)
    ).

/*------------------------------------------------------------------------*/
IdentCont<IdentNode i, out StmtNode s>                      (. s = null; Block b = new Block(); .)
    = Assign<out ExprNode expr>                     (. s = new AssignNode(i, expr); .)
     | EdgeOpr<out int op>                      
     EdgeOneOrMore<i, op, ref b>                          (. s = b; .)
     .


/*------------------------------------------------------------------------*/
Member<ExprNode source, out MemberNode mem> =    (. mem = null; .)
    WEAK '.' CallOrID<out IdentNode i>          (. mem = new MemberNode(source, i); .)
    .

/*------------------------------------------------------------------------*/
FullDecl<ref Block block> =
    Type<out int typ> 
    (
        IDENT                               (. string name = t.val; ExprNode expr = null; .)
        [
            Assign<out expr>
        ]                                   (. block.Add(new VarDeclNode(typ, name, expr)); .)
    | 
        '{' 
            VtxDecls<ref block>
        '}' 
    | 
        VtxDecl<out VertexDeclNode VertexDecl>      (. block.Add(VertexDecl); .)
    ).

/*------------------------------------------------------------------------*/
Assign<out ExprNode expr>                   (. expr = null; .)
    = '=' 
    (Expr<out expr>
    | '{' Args<out CollecConst collec>      (. expr = collec; .)
    '}'
    ).

/*------------------------------------------------------------------------*/
VtxDecls<ref Block b>                            
    = VtxDecl<out VertexDeclNode v1>            (. b.Add(v1); .)
    {WEAK ',' VtxDecl<out VertexDeclNode v2>    (. b.Add(v2); .)
    }.

/*------------------------------------------------------------------------*/
VtxDecl<out VertexDeclNode v>                    (. v = null; .)
    = '(' IDENT                              (. v = new VertexDeclNode(Types.vertex, t.val); .)
    VEParams<v>               
    ')'.


/*------------------------------------------------------------------------*/
EdgeOpr<out int op>            (. op = 0; .)
    = ("<-"                    (. op = Operators.LEFTARR;     .)
    | "--"                    (. op = Operators.NONARR;     .)
    | "->"                    (. op = Operators.RIGHTARR;     .)
    ).

/*------------------------------------------------------------------------*/
EdgeOneOrMore<IdentNode left, int op, ref Block b>  
    = (Identifier<out VarNode varNode>              (. b.Add(new EdgeDeclNode(left, varNode, op)); .)
    | EdgeDecl<left, op, out EdgeDeclNode edge>     (. b.Add(edge); .)
    | '{' EdgeDecls<left, op, ref b>                
    '}').

/*------------------------------------------------------------------------*/
EdgeDecls<IdentNode left, int op, ref Block b>
    = EdgeDecl<left, op, out EdgeDeclNode e1>                (. b.Add(e1); .)
    {WEAK ',' EdgeDecl<left, op, out EdgeDeclNode e2>        (. b.Add(e2); .)
    }.

/*------------------------------------------------------------------------*/
EdgeDecl<IdentNode left, int op, out EdgeDeclNode edge>   (. edge = null; .)
    = '(' Identifier<out VarNode right>                   (. edge = new EdgeDeclNode(left, right, op); .)
    VEParams<edge>                           
    ')'.


/*------------------------------------------------------------------------*/
VEParams<VEDeclNode ve>                             
    = {WEAK ',' Identifier<out VarNode varNode>         
     Assign<out ExprNode expr>                       (. ve.AddAttr(new AssignNode(varNode, expr)); .)
     }.


/*------------------------------------------------------------------------*/
Expr<out ExprNode e>                (. e = null; .)
    = ExprOR<out e>.
    
/*------------------------------------------------------------------------*/
ExprOR<out ExprNode e>              (. e = null; int op = 0; .)
    = ExprAnd<out ExprNode e1>      (. e = e1; .)
    {"||"                           (. op  = Operators.OR; .)
    ExprAnd<out ExprNode e2>        (. e = new BinExprNode(e, op, e2); .)                                
    }.

/*------------------------------------------------------------------------*/
ExprAnd<out ExprNode e>             (. e = null; int op = 0; .)
    = ExprEQ<out ExprNode e1>       (. e = e1; .)
    {"&&"                           (. op = Operators.EQ; .)
    ExprEQ<out ExprNode e2>         (. e = new BinExprNode(e, op, e2); .)
    }.

/*------------------------------------------------------------------------*/
ExprEQ<out ExprNode e>              (. e = null; int op = 0; .)
    = ExprRel<out ExprNode e1>      (. e = e1; .)
    [("=="                          (. op = Operators.EQ; .)
    | "!="                          (. op = Operators.NEQ; .)
    ) ExprRel<out ExprNode e2>      (. e = new BinExprNode(e, op, e2); .)
    ].

/*------------------------------------------------------------------------*/
ExprRel<out ExprNode e>             (. e = null; int op = 0; .)
    = ExprPlus<out ExprNode e1>     (. e = e1; .)
    [('<'                           (. op = Operators.LESS; .)
    | '>'                           (. op = Operators.GREATER; .)
    | "<="                          (. op = Operators.LESSEQ; .)
    | ">="                          (. op = Operators.GREATEQ; .)
    ) ExprPlus<out ExprNode e2>     (. e = new BinExprNode(e, op, e2); .)
    ].

/*------------------------------------------------------------------------*/
ExprPlus<out ExprNode e>            (. e = null; bool b = false; int op = 0; .)
    = ['-'                          (. b = true; .)
    ] ExprMult<out ExprNode e1>     (. if(b) e = new UnaExprNode(Operators.UMIN, e1); else e = e1; .)
    {('+'                           (. op = Operators.PLUS; .)
    | '-'                           (. op = Operators.BIMIN; .)
    ) ExprMult<out ExprNode e2>     (. e = new BinExprNode(e, op, e2); .)
    }.

/*------------------------------------------------------------------------*/
ExprMult<out ExprNode e>            (. e = null; int op = 0;.)
    = ExprNot<out ExprNode e1>      (. e = e1; .)
    {('*'                           (. op = Operators.MULT; .)
    | '/'                           (. op = Operators.DIV; .)
    | '%'                           (. op = Operators.MOD; .)
    ) ExprNot<out ExprNode e2>      (. e = new BinExprNode(e, op, e2); .)
    }.

/*------------------------------------------------------------------------*/
ExprNot<out ExprNode e>             (. e = null; bool b = false;.)
    = ['!'                          (. b = true; .)
    ] Factor<out e>                 (. if(b) e = new UnaExprNode(Operators.NOT, e); .)
    .

/*------------------------------------------------------------------------*/
Factor<out ExprNode e>                                  (. e = null; .)
    =
    Const<out e>
    | 
    (
        '(' 
            Expr<out e> 
        ')' 
        | 
        CallOrID<out IdentNode ident>                    (. e = ident; .)
    ) 
    {
        Member<e, out MemberNode member>                   (. e = member; .)
    }
    .        


/*------------------------------------------------------------------------*/
CallOrID<out IdentNode i> =                 (. i = null; .)
    Identifier<out VarNode varNode>         (. i = varNode; .)
    [
        '(' 
            Args<out CollecConst collec>    (. i = new CallNode(i.identifier, collec); .)
        ')'
    ].

/*------------------------------------------------------------------------*/
Args<out CollecConst collec> =      (. collec = new CollecConst(); ExprNode expr; .)
    [
        Expr<out expr>              (. collec.Add(expr); .)
        {
            WEAK ',' Expr<out expr> (. collec.Add(expr); .)
        }
    ].


/*------------------------------------------------------------------------*/
Identifier<out VarNode varNode> =   (. varNode = null; .)
    (
        IDENT                       (. varNode = new VarNode(t.val); .)
    ).

/*------------------------------------------------------------------------*/
Const<out ExprNode e> =     (. e = null; .)
    ( NUMBER                (. e = new NumConst(Convert.ToDouble(t.val));    .)
    | TEXT                  (. e = new TextConst(t.val);                    .)
    | TRUE                  (. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | FALSE                 (. e = new BoolConst(Convert.ToBoolean(t.val)); .)
    | NONE                  (. e = new NoneConst();                         .)
    ).

/*------------------------------------------------------------------------*/
Type<out int type> =        (. type = 0; .)
    ( SingleType<out type>
    | CollecType<out type>
    ).

/*------------------------------------------------------------------------*/
CollecType<out int type> =                                     (. type = 0; int subType = 0; .)
    ( "list" WEAK '<' SingleType<out subType> WEAK '>'         (. type = Types.list + subType; .)
    | "set" WEAK '<' SingleType<out subType> WEAK '>'          (. type = Types.set + subType; .)
    | "queue" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.queue + subType; .)
    | "stack" WEAK '<' SingleType<out subType> WEAK '>'        (. type = Types.stack + subType; .)
    ).
/*------------------------------------------------------------------------*/
SingleType<out int type> = (. type = 0; .)
    ( "number"             (. type = Types.number; .)
    | "bool"               (. type = Types.boolean; .)
    | "text"               (. type = Types.text; .)
    | "vertex"             (. type = Types.vertex; .)
    | "edge"               (. type = Types.edge; .)
    ).

/*------------------------------------------------------------------------*/

END MAGIA.
